# Two Sum(Easy)

## Problem Statement

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:
    Input: nums = [2,7,11,15], target = 9
    Output: [0,1]
    Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:
    Input: nums = [3,2,4], target = 6
    Output: [1,2]

Example 3:
    Input: nums = [3,3], target = 6
    Output: [0,1]

Constraints:
    2 <= nums.length <= 104
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    Only one valid answer exists.

## Solutions

### Brute Approach

#### Logic
    - Loop through each number in the array.
    - For each number, check every other number (after the current one) to see if the sum of the two numbers equals the target.
    - If you find such a pair, return their indices.

#### Implementation (C++)
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            int n = nums.size();
            for(int i = 0; i < n; i++){
                for(int j = i + 1; j < n; j++){
                    if(nums[i] + nums[j] == target){
                        return {i, j};
                    }
                }
            }
            return {-1, -1};
        }
    };

#### Explaination
    - We use two loops:
        - The first loop (i) picks each number in the array.
        - The second loop (j) picks the other numbers after the current number (i).
    - If the sum of nums[i] and nums[j] equals the target, we return their indices {i, j}.
    - Since each pair is checked, this approach will always find the correct answer (if one exists).
    - If no answer is found, we return {-1, -1}, but this will never happen, as the problem guarantees that an answer always exists.

#### Time & Space Complexities
    Time Complexity: O(n^2), where n is the number of elements in the input vector `nums`.
    This is because there are two nested loops: the outer loop runs n times, and for each iteration of the outer loop, the inner loop runs up to n-1 times in the worst case. Therefore, the total number of iterations is proportional to n * (n - 1) / 2, which simplifies to O(n^2).

    Space Complexity: O(1)
    The algorithm uses a constant amount of extra space for variables like `i` and `j`. The output is a vector of size 2, which does not depend on the size of the input, so it can also be considered O(1) in terms of additional space used.


